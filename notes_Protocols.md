# Протоколы и форматы


## Формат URL (Uniform Resource Locator)

`<схема>://<логин>:<пароль>@<хост>:<порт>/<URL‐путь к ресурсу>?<параметры>#<якорь>`

Элемент | Значение | Примеры | Обязательность | Множественность
--------|----------|---------|----------------|----------------
Схем | Протокол для доступа к ресурсу | http, https, ftp | Обязательный | Один
Логин | Имя пользователя для аутентификации | username | Необязательный | Один
Пароль | Пароль для аутентификации | password | Необязательный | Один
Хост | Доменное имя или IP-адрес сервера | example.com, 192.0.2.1 | Обязательный | Один
Порт | Номер порта для доступа к ресурсу | 80, 443, 8080 | Необязательный | Один
URL-путь к ресурсу | Иерархическая структура для указания пути к конкретному ресурсу на сервере | /dir/file.html, /dir/file | Может отсутствовать. Например, в URL: https://www.example.com/. Это значит, что мы обращаемся к корневому ресурсу на сервере (допустим, к главной странице, где расположены уже ссылки на другие ресурсы). | Один
Параметры | Дополнительная информация, передаваемая серверу в виде пар "ключ=значение". Если параметров несколько, то они соединяются через &. | query=search&page=2 | Необязательный | Много
Якорь | Идентификатор фрагмента на веб-странице для прокрутки до указанного места. Например, указатель на определённую главу в статье на википедии. Позволяет быстро перемещаться по статье прямо из содержания. | #section1, #footer | Необязательный | Один

Пример:  
`https://user:password@example.org:2121/files?search=report#results`


## Набор протоколов TCP/IP (Transmission Control Protocol/Internet Protocol)

Описывают способы организации и функционирования компьютерных сетей, уравляют передачей информации в интернете между устройствами. Состоит из 4 уровней (канальный, сетевой, транспортный, прикладной), которые охватывают сетевую коммуникации от передачи данных на низком уровне до обработки приложений на более высоком уровне.

*Порт* - это уникальный номер потока данных в устройство/программу на транспортном уровне.  
Чтобы доставить данные в нужную программу, серверу необходимо знать IP адрес на сетевом уровне и порт на транспортном уровне.

Некоторые стандартные TCP/UDP порты:
- 7 - ECHO (для тестирования)
- 20, 21 - FTP
- 22 - SSH
- 23 - Telnet
- 25 - SMTP
- 53 - DNS
- 80 - HTTP
- 110 - POP3
- 143 - IMAP
- 161, 162 - SNMP
- 220 - IMAP3
- 443 - HTTPS
- 989, 990 - FTPS
- 992 - TelnetS
- 993 - IMAPS
- 995 - POP3S
- 1645, 1646 - RADIUS
- 2046-2048, 2050 - ViPNet
- 5353 - Multicast DNS
- 20014, 32810-32814/UDP - World of Tanks
  [полный список (ru)](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2_TCP_%D0%B8_UDP), [полный список (en)](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers)

*Сокет* - пара IP-адрес и порт (IP:PORT), например 127.0.0.1:8080.


## Модель OSI (Open Systems Interconnection)

Предоставляет описание взаимодействия сетевых протоколов для обеспечения передачи данных в компьютерных сетях. состоит из 7 уровней (физический, канальный, сетевой, транспортный, сеансовый, представления, прикладной), каждый из которых описывает определенный аспект сетевой коммуникации, начиная с физической передачи сигналов до высокоуровневых приложений.


## Формат JSON

Состоит из объектов, внутри которых находятся параметры, представляющие собой пары ключ(поле)-значение. Объект и содержимое объекта заключается в фигурные скобки. Имя объекта и его содержимое, а также ключ и его значение разделяются двоеточием. Пары ключ-значение внутри объекта разделяются запятыми. Cтроковые данные (включая ключи объекта и строковые значения) заключаются в кавычки и являются чувствительными к регистру. Другие типы значений (числа, логические значения, массивы и объекты) не зависят от регистра.

JSON | Тип данных
-------|-----------
`{` | 
`"employee":{` | - объект
`"name":"Иван",` | - ключ со строковым значением
`"age":35,` | - ключ с числовым значением
`"is_man":true,` | - ключ с логическим значением
`"last_name"null,` | - ключ с нулевым значением
`"cars":["BMW", "Honda"]` | - ключ с массивом
`}` | 
`}` | 


Пример содержимого объекта с массивом объектов внутри:
```json
{
    "squadName": "Super hero squad",
    "formed": 2016,
    "active": true,
    "members": [{
            "name": "Molecule Man",
            "age": 29,
            "powers": [
                "Radiation resistance",
                "Turning tiny"
            ]
        },
        {
            "name": "Madame Uppercut",
            "age": 39,
            "powers": [
                "Million tonne punch",
                "Damage resistance"
            ]
        }
    ]
}
``` 

[Ссылка на валидатор JSON.](https://jsonlint.com/)


## Формат XML

Расширяемый язык разметки. Используется для хранения и передачи данных.  
Является единственно возможным форматом для API SOAP.

XML документ или запрос состоит из элементов, которые заключаются в тэги - угловые скобки, обозначающеи начало и конец элемента. Текст внутри угловых скобок - это название тэга, повторяется в начале и в конце элемента. Закрывающий тэг отличается от открывающего наличием перед названием тэга обратного слэша.  
Корневой элемент - это тэг с которого документ начинается и которым заканчивается.  
Внутри корневого элемента расположено тело запроса(документа), состоящее из элементов-параметров. Параметры также начинаются и заканчиваются тэгами, между открывающим и закрывающим тэгом параметра находится значение параметра. Все значения параметров указываются без кавычек. Элементы(параметры) могут быть одиночными и с вложенными дочерними элементами.  
Внутри открывающего тэга могут быть атрибуты тэга - значения, которые передаются в тэг. Атрибут и его значение разделяются знаком равенства. Значения атрибутов указываются в кавычках.  
В начале XML документа, до корневого тэга может располагаться необязательный элемент - XML-пролог. Он начинается с `<?xml ...>`, и определяет версию XML и кодировку.

Пример XML документа:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<bookstore>

  <book category="cooking">
    <title lang="en">Everyday Italian</title>
    <author>Giada De Laurentiis</author>
    <year>2005</year>
    <price>30.00</price>
  </book>

  <book category="children">
    <title lang="en">Harry Potter</title>
    <author>J K. Rowling</author>
    <year>2005</year>
    <price>29.99</price>
  </book>

</bookstore>
```

### XDS схема (XML Schema Definition)

Это шаблон на соответствие которому проверяются XML документы (запросы и ответы). Используется в составе API SOAP, пишется на языке XML, содержит:
- элементы и их атрибуты, которые должны быть в XML документе;
- количество и порядок дочерних элементов;
- типы данных для элементов и атрибутов;
- значения по умолчанию и фиксированные значения для элементов и атрибутов;
- ссылки на другие референсные XCD схемы.

Префикс `xs`: в XSD схемах используется для указания пространства имен (namespace) "http://www.w3.org/2001/XMLSchema", которое определяет стандартные типы данных XML Schema. При использовании элементов, типов данных и других конструкций из схемы XML, необходимо обязательно указывать префикс `xs` для того, чтобы указать, что эти элементы относятся к стандартным типам данных XML Schema. Это позволяет избежать конфликтов с другими пространствами имен (при использовании своих придуманных типов данных) и упрощает понимание структуры документа.

```xml
<?xml version="1.0" encoding="UTF-8"?>  <!--Объявление XML-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">  <!--Открывающий тэг для XDS схемы-->
  <xs:element name="squad">  <!--Корневой элемент-->
    <xs:complexType>  <!--указание на сложный тип элемента-->
      <xs:sequence>  <!--указание на соблюдение порядка следования элементов-->
        <xs:element name="squadName" type="xs:string"/>  <!--простой дочерний элемент, тип строковый-->
        <xs:element name="formed" type="xs:int"/>  <!--простой дочерний элемент, тип целочисленный-->
        <xs:element name="active" type="xs:boolean"/>  <!--простой дочерний элемент, тип логический-->
        <xs:element name="members">  <!--сложный дочерний элемент-->
          <xs:complexType>  <!--указание на сложный тип элемента-->
            <xs:sequence>  <!--указание на соблюдение порядка следования элементов-->
              <xs:element name="member" maxOccurs="unbounded">  <!--сложный дочерний элемент, количество элементов не ограничено-->
                <xs:complexType>  <!--указание на сложный тип элемента-->
                  <xs:all>  <!--указание, что элементы могут появляться в любом порядке-->
                    <xs:element name="age" minOccurs="0" type="xs:int"/>  <!--простой дочерний элемент, минимальное количество 0, тип целочисленный-->
                    <xs:element name="powers">  <!--сложный дочерний элемент-->
                      <xs:complexType>  <!--указание на сложный тип элемента-->
                        <xs:sequence>  <!--указание на соблюдение порядка следования элементов-->
                          <xs:element name="power" type="xs:string" maxOccurs="unbounded"/>  <!--простой дочерний элемент, тип строковый, количество элементов не ограничено-->
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                  </xs:all>
                  <xs:attribute name="name" type="xs:string" use="optional"/>  <!--атрибут, тип строковый, не обязательный-->
                  <xs:attribute name="age" type="xs:int" use="optional"/>  <!--атрибут, тип целочисленный, не обязательный-->
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>
```

Можно использовать свои префиксы для нестандартных типов данных. Для этого нужно объявить соответствующий пространство имен (namespace) и связать его с префиксом.  
Например, для объявления типов данных из пространства имен "http://example.com/mytypes" и связывания их с префиксом "my", можно использовать следующую инструкцию:

```xml
<xs:schema
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:my="http://example.com/mytypes">
    <!-- Определения типов данных из пространства имен "http://example.com/mytypes" -->
    <xs:complexType name="MyType">
        <xs:sequence>
            <xs:element name="myfield" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>
    <!-- Использование типа данных "MyType" с префиксом "my" -->
    <xs:element name="myelement" type="my:MyType"/>
</xs:schema>
```

[Подсказка по элементам XML и XDS.](https://msiter.ru/references/xsd-elements)

[Ссылка на валидатор XML.](https://codebeautify.org/xmlvalidator)

[Ссылка на конвертор XML в XSD.](https://extendsclass.com/xml-schema-validator.html)


## API SOAP

[`SoupUI`](https://github.com/SmartBear/soapui) - программа для тестирования API SOAP.