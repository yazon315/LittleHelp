# SQL

**Оглавление**

- [SQL](#sql)
  - [Порядок записи и выполнения операторов в команде SELECT](#порядок-записи-и-выполнения-операторов-в-команде-select)
    - [Порядок записи операторов](#порядок-записи-операторов)
    - [Порядок выполнения операторов](#порядок-выполнения-операторов)
  - [Типы данных и изменение типов данных](#типы-данных-и-изменение-типов-данных)
  - [Встроенные функции](#встроенные-функции)
    - [Функции для работы с числами](#функции-для-работы-с-числами)
    - [Функции для работы со строками](#функции-для-работы-со-строками)
    - [Функции для работы с датой и временем](#функции-для-работы-с-датой-и-временем)
    - [Агрегирующие функции](#агрегирующие-функции)
    - [Прочие встроенные функции](#прочие-встроенные-функции)
      - [Функция `DISTINCT`](#функция-distinct)
      - [Функция `CASE`](#функция-case)
      - [Функция `IF`](#функция-if)
      - [Функция `IFNULL`](#функция-ifnull)
      - [Функция `COALESCE`](#функция-coalesce)
  - [Подзапросы и временные таблицы](#подзапросы-и-временные-таблицы)
    - [Подзапросы](#подзапросы)
    - [Временные таблицы (CTE)](#временные-таблицы-cte)
    - [Представления (VIEW)](#представления-view)
  - [Объединение таблиц](#объединение-таблиц)
    - [Операторы `JOIN` (горизонтальное объединение)](#операторы-join-горизонтальное-объединение)
    - [Операторы `UNION` (вертикальное объединение)](#операторы-union-вертикальное-объединение)
  - [Оконные функции](#оконные-функции)
    - [Функции в составе оконных функций](#функции-в-составе-оконных-функций)
    - [Конструкция `WINDOW`](#конструкция-window)
    - [Ограничения оконных функций](#ограничения-оконных-функций)
  - [Индексы](#индексы)
  - [Разное](#разное)
    - [Просмотр таблиц и типов данных в них](#просмотр-таблиц-и-типов-данных-в-них)
    - [Команда `EXPLAIN`](#команда-explain)
    - [Рекомендации по оптимизации SQL-запросов](#рекомендации-по-оптимизации-sql-запросов)

SQL - обладающий вариативностью декларативный язык, с помощью которого описывают конечный результат, а не алгоритм.

База данных - структура в которой данные упорядочены и связаны между собой.

Реляционная база данных - структура в которой данные представлены в виде связанных таблиц.  
Таблицы содержат: строки, поля, ячейки.  
В таблицах реляционной базы отсутствуют дубликаты, все записи уникальны.  
Для каждой записи добавляется уникальный признак - первичный ключ - поле или набор полей таблицы с уникальными значениями, однозначно идентифицирующими строки таблицы.  
Связь между таблицами в базе данных обеспечивается внешними ключами, с их помощью таблицы можно объединять.  
Схема - уровень структуризации реляционной базы данных. Каждая база данных содержит одну или несколько схем, в которые, в свою очередь, входят таблицы. В разных схемах могут быть таблицы с одинаковыми названиями. Если при создании таблицы не добавить конкретную схему, то таблица будет помещена в схему public, которая по умолчанию входит в каждую новую базу данных PostgreSQL. Если таблица находится в схеме public, то название схемы в запросе можно не указывать.  
В общем случае название схемы указывается через точку перед названием таблицы, например: `FROM shema.tablica`.  
Поле таблицы указывается или своим названием, или своим названием через точку после названия таблицы,например: `tablica.pole`.



## [Порядок записи и выполнения операторов в команде SELECT](#sql)


### [Порядок записи операторов](#sql)

```SQL
SELECT ..., ... AS ... --выбор данных для отображения
    DISTINCT ..., ... /*выбор уникальных значений*/
    CASE --проверка набора условий
        WHEN условие_1 THEN значение_1
        WHEN условие_2 AND условие_3 THEN значение_2
        ELSE значение_3
    END
    IF(условие, значение_истина, значение_ложь) -- проверка условия
    IFNULL(выражение, значение) --проверка на равенство NULL
    COALESCE(выражение_1, выражение_2, ..., выражение_N) -- выбор первого выражения не равного NULL
    SUM/AVG/MIN/MAX/COUNT() --применение агрегирующих функций
    функция() OVER(PARTITION BY ... ORDER BY ...) AS ... --применение оконных функций
FROM таблица_1 AS псевдоним_1
    INNER JOIN таблица_2 ON таблица_1.имя_поля = таблица_2.имя_поля --первое присоединение
    LEFT OUTER JOIN таблица_3 AS псевдоним_3 ON псевдоним_1.имя_поля = псевдоним_3.имя_поля --второе присоединение
    RIGHT OUTER JOIN --третье присоединение
    FULL OUTER JOIN --четвертое присоединение
WHERE ... --получение среза данных
    OR NOT ...
    AND ... IN (..., ..., ...)
    AND ... NOT IN (...)
    AND EXISTS (подзапрос)
    AND NOT EXISTS (подзапрос)
    AND ... LIKE '%...%'
    AND ... NOT LIKE '_...%'
    AND ... REGEXP 'регулярное_выражение'
    AND ... NOT REGEXP 'регулярное_выражение'
    OR ... BETWEEN ... AND ...
    OR ... IS NULL
    OR ... IS NOT NULL
WINDOW ...
GROUP BY ..., ... --группировка данных
HAVING ... --получение среза после GROUP BY
ORDER BY ..., ... DESC, ... ASC --сортировка перед выводом данных
LIMIT ... OFFSET ...; -- ограничение количества выводимых данных
```

*Примечения:*  
- Псевдонимы (собственные названия для чего-либо) назначаются через `AS`.
- Псевдонимы таблиц, назначенные в `FROM`, можно использовать в любом месте запроса.
- Псевдонимы полей отображения, назначенные в `SELECT`, можно использовать только в `ORDER BY` (в некоторых SQL ещё и в `GROUP BY`).
- `SELECT *` - выбор всех полей таблицы.
- `SELECT` работает как функция вывода на экран (print), если он один и после него указать строку или число, например:
    ```SQL
    SELECT 'на экране отображается число', 5;
    ```


### [Порядок выполнения операторов](#sql)

1. Первым выполняется оператор `FROM`, так как сначала нужно определить, откуда брать данные. На этом же этапе с помощью оператора `JOIN` объединяются таблицы и назначаются псевдонимы для таблиц.  
Важно учесть, что присоединение предшествует фильтрации и группировке. Это означает, что большие таблицы будут объединяться очень долго. В этом случае рекомендуется использовать временные таблицы.
2. Затем выполняется оператор `WHERE`, который оставляет только те данные, которые соответствуют условиям (срезы).
3. После срезов выполняется группировка оператором `GROUP BY` и подсчёт данных агрегирующими функциями.  
Обратите внимание, что `WHERE` предшествует `GROUP BY`, что не позволяет сделать срез по группам (в момент получения среза группировка ещё не произошла).
4. Далее наступает очередь `HAVING` — отбираются уже сгруппированные данные.
5. Только после этого происходит выбор данных с помощью оператора `SELECT` и полям в итоговой таблице присваиваются псевдонимы. По этой причине псевдонимы нельзя использовать после `WHERE` и `HAVING` — они ещё не назначены (в некоторых СУБД псевдонимы нельзя использовать и после `GROUP BY`).
6. После `SELECT` срабатывает ключевое слово `DISTINCT`, которое отбирает уникальные значения.
7. Оператор `ORDER BY` действует предпоследним, выполняя сортировку.
8. Последним выполняется оператор `LIMIT`.



## [Типы данных и изменение типов данных](#sql)

В разных СУБД типы данных могут отличаться, но типы данных часто можно объединить в похожие группы. В PostgreSQL выделяют следующие группы [типов данных](https://postgrespro.ru/docs/postgresql/15/datatype):
- числовые типы:
  - `integer` (псевдоним `int` или `int4`) - целые числа;
  - `real` (псевдоним `float4`) - вещественные числа (4 байта);
  - `double precision` (псевдоним `float8`) - вещественные числа (8 байт);
- символьные типы:
  - `character` (псевдоним `char(n)`, где n - количество символов) - символьная строка фиксированной длины;
  - `character varying` (псевдоним `varchar(n)`, где n - количество символов, который можно не уквзывать) - символьная строка переменной длины;
  - `text` - символьная строка переменной длины (не для всех SQL);
- логические типы:
  - `boolean` (псевдоним `bool`) - логическое значение:
    - `TRUE` (варианты обозначения: `true`, `t`, `yes`, `y`, `on`, `1`);
    - `FALSE` (варианты обозначения: `false`, `f`, `no`, `n`, `off`, `0`);
- типы для работы с датой и временем:
  - `timestamp` - дата и время без учета часового пояса (например, 2004-10-19 10:23:54);
  - `timestamptz` - дата и время с учетом часового пояса (например, 2004-10-19 10:23:54+02);
  - `date` - дата (например, `2004-10-19`, `October 19, 2004`, `2004-Oct-19` или `20041019`);
  - `time` - время без учета часового пояса;
  - `timetz` - время с учетом часового пояса;
  - `interval` - интервал времени;
- разные специализированные типы для конкретных задач.


**Изменение типа данных при выгрузке (в самой базе данные не меняются):**
```SQL
CAST(имя_поля AS тип_данных)
```
Альтернативный вариант изменения типа данных при выгрузке:
```SQL
имя_поля::тип_данных
```



## [Встроенные функции](#sql)


### [Функции для работы с числами](#sql)

- `ABS()` - возвращает абсолютное значение (модуль) числа.
  
  Пример: `SELECT ABS(-123)`  -->  `123`
  
- `CEILING()` - возвращает число, округлённое до целого в большую сторону.
  
  Пример: `SELECT CEILING(-123.45)`  -->  `-123`  
  `SELECT CEILING(123.45)`  -->  `124`
  
- `FLOOR()` - возвращает число, округлённое до целого в меньшую сторону.
  
  Пример: `SELECT FLOOR(-123.45)`  -->  `-124`  
  `SELECT FLOOR(123.45)`  -->  `123`
  
- `ROUND(число, количество_знаков)` - округляет значение до ближайшего целого числа (если не указано количество знаков) или до указанного количества знаков после запятой. Если количество знаков указано отрицательным числом, то округление идет до запятой (до десятков, сотен и т.д.).
  
  Пример: `SELECT ROUND(1342.345, -2)`  -->  `1300`
  
- `TRUNC(число, количество_знаков_после_запятой)` - усекает значение до ближайшего целого числа (если не указано количество знаков после запятой) или до указанного количества знаков после запятой, но число, в отличии от `ROUND`, не округляется.  
  В `PostgreSQL` название функции `TRUNC`, в `MySQL` название функции `TRUNCATE`.

  Пример: `SELECT TRUNCATE(1342.345, 2)`  -->  `1342.34`
  
- `POWER(число, степень)` - возводит число в указанную степень.
  
  Пример: `SELECT POWER(5, 3)`  -->  `125`
  
- `SQRT()` - возвращает квадратный корень из числа.
  
  Пример: `SELECT SQRT(225)`  -->  `15`

- `SIGN()` - возвращает `1`, если число больше 0, возвращает `-1`, если число меньше 0, возвращает 0, если число равно 0.
  
  Пример: `SELECT SIGN(7));       -- 1`

- `RAND()` - генерирует случайное число с плавающей запятой в диапазоне от 0 до 1.
  
  Пример: `SELECT RAND()`  -->  `0.707365088352935`


### [Функции для работы со строками](#sql)

- `CONCAT()` - объединяет строки, в качестве параметра принимает две и более строки. Кроме строк, в функцию могут передавать числа и даты, которые будут преобразовываться в строки и объединяться.
  
  Пример: `SELECT CONCAT('слово слово', ' ', '12', 'текст')`  -->  `слово слово 12текст`

- `CONCAT_WS()` - объединяет строки, в качестве первого параметра принимает разделитель, который соединяет строки.
  
  Пример: `SELECT CONCAT_WS(' ', 'слово', 'текст', ' ', 34)`  -->  `слово текст   34`

- `LENGTH()` - возвращает количество символов в строке, в качестве параметра в функцию передается строка, для которой надо найти длину.
  
  Пример: `SELECT LENGTH('Два слова.')`  -->  `10`

- `LTRIM()` - удаляет пробелы в начале строки, в качестве параметра принимает строку.
  
  Пример: `SELECT LTRIM('  слово')`  -->  `слово`

- `RTRIM()` - удаляет пробелы в конце строки, в качестве параметра принимает строку.
  
  Пример: `SELECT RTRIM('слово слово    ')`  -->  `слово слово`

- `TRIM()` - удаляет пробелы в начале и конце строки, в качестве параметра принимает строкую. С помощью дополнительного оператора можно задать, где именно удалить пробелы: `BOTH` - в начале и в конце; `TRAILING` - только в конце; `LEADING()` - только в начале.
  
  Пример: `SELECT TRIM(BOTH FROM '  слова слова   ')`  -->  `слова слова`

- `LOCATE(find, search [, start])` - возвращает позицию первого вхождения подстроки `find` в строку `search`. Дополнительный параметр `start` позволяет установить позицию в строке `search`, с которой начнется поиск подстроки `find`. Если подстрока не найдена, то возвращается 0.
  
  Пример: `SELECT LOCATE('о', 'слово слова', 4)`  -->  `5`

- `LEFT()` - вырезает определенное количество символов с начала строки. Принимает два параметра: первый - строка, второй - количество символов, которые надо вырезать с начала строки.
  
  Пример: `SELECT LEFT('слова', 3)`  -->  `сло`

- `RIGHT` - вырезает определенное количество символов с конца строки. Принимает два параметра: первый - строка, второй - количество символов, которые надо вырезать с конца строки.
  
  Пример: `SELECT RIGHT('слова', 3)`  -->  `ова`

- `SUBSTRING(str, start [, length])` - вырезает из строки `str` подстроку, начиная с позиции `start` с количеством символов `length`. Если переметр `length` не указан, то вырезает до конца строки.
  
  Пример: `SELECT SUBSTRING('Galaxy S8 Plus', 8, 2)`  -->  `S8`

- `SUBSTRING_INDEX(str, delimiter, count)` - вырезает из строки `str` подстроку. Параметр `delimiter` определяет разделитель внутри строки, параметр `count` определяет до какого вхождения разделителя надо вырезать подстроку. Если значение параметра `count` положительное, то подстрока вырезается с начала строки `str`, если значение `count` отрицательное, то с конца строки.
  
  Пример: `SELECT SUBSTRING_INDEX('Galaxy S8 Plus', ' ', 2)`  -->  `Galaxy S8`

- `REPLACE(search, find, replace)` - заменяет в строке `search` подстроку `find` на подстроку `replace`. Первый параметр - строка, второй - подстрока, которую надо заменить, третий - подстрока, на которую надо заменить.
  
  Пример: `SELECT REPLACE('Galaxy S8 Plus', 'S8 Plus', 'Note 8')`  -->  `Galaxy Note 8`

- `INSERT(str, start, length, insert)` - вставляет в строку `str` подстроку `insert`, заменяя при этом `length` символов с позиции `start`. Первый параметр - строка, второй - позиция, с которой надо заменить, третий - сколько символов с позиции `start` надо заменить вставляемой подстрокой, четвертый - вставляемая подстрока.
  
  Пример: `SELECT INSERT('Galaxy S9', 8, 2, 'Note 9')`  -->  `Galaxy Note 9`

- `REVERSE()` - переворачивает строку с конца.
  
  Пример: `SELECT REVERSE('123456789')`  -->  `987654321`

- `LOWER()` - переводит строку в нижний регистр.
  
  Пример: `SELECT LOWER('СлоВо')`  -->  `слово`

- `UPPER()` - переводит строку в верхний регистр.
  
  Пример: `SELECT UPPER('Слово')`  -->  `СЛОВО`

- `SPACE()` - возвращает строку, которая содержит определенное количество пробелов.
  
  Пример: `SELECT SPACE(5)`  --> `     `
  
- `REPEAT(str, count)` - возвращает строку, которая содержит определенное количество повторов подстроки `str`. Количество повторов задается параметром `count`.
  
  Пример: `SELECT REPEAT('слово', 3)`  --> `словословослово`

- `LPAD(str, length, pad)` - добавляет слева от строки `str` некоторое количество символов, которые определены в параметре `pad`. Количество добавляемых символов вычисляется по формуле `length - LENGTH(str)` (выдаваемая строка будет длиною `length`). Если параметр `length` меньше длины строки `str`, то строка усекается до `length` символов.
  
  Пример: `SELECT LPAD('Tom Smith', 13, '*')` -  -->  `****Tom Smith`

- `RPAD(str, length, pad)` - добавляет справа от строки `str` некоторое количество символов, которые определены в параметре `pad`. Количество добавляемых символов вычисляется по формуле `length - LENGTH(str)` (выдаваемая строка будет длиною `length`). Если параметр `length` меньше длины строки `str`, то строка усекается до `length` символов.
  
  Пример: `SELECT RPAD('Tom Smith', 13, '*')`  -->  `Tom Smith****`


### [Функции для работы с датой и временем](#sql)

```SQL
-- три одинаковые функции возвращают текущие дату и время:
SELECT CURRENT_TIMESTAMP()
SELECT NOW()
SELECT SYSDATE()

-- две одинаковые функции возвращают текущую дату:
SELECT CURRENT_DATE()
SELECT CURDATE()

-- две одинаковые функции возвращают текущее время:
SELECT CURRENT_TIME()
SELECT CURTIME()


SELECT UTC_DATE() -- возвращает текущую локальную дату относительно GMT

SELECT UTC_TIME() -- возвращает текущее локальное время относительно GMT
```

**Извлечение определенных промежутков дат и времени**
- `DAYOFMONTH(date)` - возвращает день месяца в виде числового значения
- `DAYOFWEEK(date)` - возвращает день недели в виде числового значения
- `DAYOFYEAR(date)` - возвращает номер дня в году
- `MONTH(date)` - возвращает месяц даты
- `YEAR(date)` - возвращает год из даты
- `QUARTER(date)` - возвращает номер квартала года
- `WEEK(date [, first])` - возвращает номер недели года, параметр `first` задает стартовый день недели, если он равен `1`, то первым днем недели считается понедельник, иначе первый день - воскресенье
- `LAST_DAY(date)` - возвращает последний день месяца в виде даты
- `DAYNAME(date)` - возвращает название дня недели
- `MONTHNAME(date)` - возвращает название текущего месяца
- `HOUR(time)` - возвращает час времени
- `MINUTE(time)` - возвращает минуту времени
- `SECOND(time)` - возвращает секунду времени


**Усечение даты-времени до определенного значения**  
До определенного значения не урезается, а округляется, например, до первого дня месяца или первого января года. Возвращает данные типов `timestamp` или `interval`.
```SQL
DATE_TRUNC('отрезок времени', имя_поля)
```
, где отрезок времени это:
- `microseconds` — микросекунды;
- `milliseconds` — миллисекунды;
- `second` — секунда;
- `minute` — минута;
- `hour` — час;
- `day` — день;
- `week` — неделя;
- `month` — месяц;
- `quarter` — квартал;
- `year` — год;
- `decade` — десятилетие;
- `century` — век.

**Получение конкретной части даты-времени**  
Вырезает из даты-времени указанную часть. Возвращает данные типа `double precision` (вещественное число).
```SQL
EXTRACT(отрезок времени FROM имя_поля)
```
, где отрезок времени это:
- `SECOND` — секунда;
- `MINUTE` — минута;
- `HOUR` — час;
- `DAY` — день;
- `MONTH` — месяц;
- `YEAR` — год;
- дополнительно в `PostgreSQL`:
  - `MILLISECOND` — миллисекунда;
  - `DOY` — день года, выраженный числом от 1 до 365 (366 для високосного года);
  - `DOW` — день недели, выраженный числом от 0 до 6 (понедельник — 1, воскресенье — 0);
  - `ISODOW` — день недели, выраженный числом от 1 до 7 (понедельник — 1, воскресенье — 7);
  - `WEEK` — неделя в году;
  - `QUARTER` — квартал;
  - `CENTURY` — век;
- дополнительно в `MySQL`:
  - MINUTE_SECOND (минуты и секунды);
  - HOUR_MINUTE (часы и минуты);
  - DAY_HOUR (день и часы);
  - YEAR_MONTH (год и месяц);
  - HOUR_SECOND (часы, минуты и секунды);
  - DAY_MINUTE (день, часы и минуты);
  - DAY_SECOND (день, часы, минуты и секунды).

*Примечание*  
Функции `DATE_TRUNC` и `EXTRACT` при работе автоматически переводят типы `date` и `time` в `timestamp with time zone`. В результате время может сдвинуться.  
Чтобы этого избежать, надо при применении функции принудительно изменить тип данных на `timestamp`.  
Пример: `EXTRACT(YEAR FROM CAST(имя_поля AS timestamp))`.


**Манипуляции с датами**  

- `DATE_ADD(date, INTERVAL expression unit)` - возвращает объект DATE или DATETIME, который является результатом сложения даты `date` с определенным временным интервалом, заданным с помощью выражения `INTERVAL expression unit`, где `INTERVAL` - ключевое слово; `expression` - количество добавляемых к дате единиц, `unit` - тип единиц (часы, дни и т.п.). Параметр `unit` может иметь те же значения, что и в функции `EXTRACT` (DAY, HOUR и т.п.).
  
  Пример: `DATE_ADD('2018-05-25', INTERVAL 1 DAY)`  --> `2018-05-26`  
  `DATE_ADD('2018-05-25 21:31:27', INTERVAL 4 HOUR)`  -->  `2018-05-26 01:31:27`

- `DATE_SUB(date, INTERVAL expression unit)` - возвращает объект DATE или DATETIME, который является результатом вычитания из даты `date` определенного временного интервала (по аналогии с `DATE_ADD()`).
  
  Пример: `DATE_SUB('2018-05-25', INTERVAL 4 DAY)`  -->  `2018-05-21`

- `DATEDIFF(date1, date2)` - возвращает разницу в днях между датами `date1` и `date2`.
  
  Пример: `DATEDIFF('2018-05-25', '2018-05-27')`  -->  `-2`

- `TO_DAYS(date)` - возвращает количество дней с 0-го года.
  
- `TIME_TO_SEC(time)` - возвращает количество секунд, прошедших с момента полуночи.

**Форматирование даты и времени**
```SQL
DATE_FORMAT(имя_поля, шаблон) -- возвращает объект DATE или DATETIME, отформатированный с помощью шаблона

TIME_FORMAT(имя_поля, шаблон) -- возвращает объект TIME или DATETIME, отформатированный с помощью шаблона
```
Шаблон может принимать следующие значения:
- `%m`: месяц в числовом формате 01..12;
- `%с`: месяц в числовом формате 1..12;
- `%M`: название месяца (January...December);
- `%b`: аббревиатура месяца (Jan...Dec);
- `%d`: день месяца в числовом формате 00..31;
- `%e`: день месяца в числовом формате 0..31;
- `%D`: номер дня месяца с суффиксом (1st, 2nd, 3rd...);
- `%y`: год в виде двух чисел;
- `%Y`: год в виде четырех чисел;
- `%W`: название дня недели (Sunday...Saturday);
- `%a`: аббревиатура дня недели (Sun...Sat);
- `%H`: час в формате 00..23;
- `%k`: час в формате 0..23;
- `%h`: час в формате 01..12;
- `%l`: час в формате 1..12;
- `%i`: минуты в формате 00..59;
- `%r`: время в 12-ти часовом формате (hh:mm:ss AM или PM);
- `%T`: время в 24-ти часовом формате (hh:mm:ss);
- `%S`: секунды в формате 00..59;
- `%p`: AM или PM.

Примеры:
- `DATE_FORMAT('2018-05-25', '%d/%m/%y')`  -->  `25/05/18`
- `DATE_FORMAT('2018-05-25 21:25:54', '%d %M %Y')`  -->  `25 May 2018`
- `DATE_FORMAT('2018-05-25 21:25:54', '%r')`  -->  `09:25:54 PM`
- `TIME_FORMAT('2018-05-25 21:25:54', '%H:%i:%S')`  -->  `21:25:24`
- `TIME_FORMAT('21:25:54', '%k:%i')`  -->  `21:25`


### [Агрегирующие функции](#sql)

Применяютя после оператора `SELECT`. Можно сочетать с математическими функциями.

- `SUM(имя_поля)` - возвращает сумму значений;
- `AVG(имя_поля)` - находит среднее арифметическое для значений;
- `MIN(имя_поля)` - возвращает минимальное значение;
- `МАХ(имя_поля)` - возвращает максимальное значение;
- `COUNT(*)` - выводит количество записей в таблице;
- `COUNT(имя_поля)` - выводит количество записей в поле.

**Ограничения агрегирующих функций:**
- Оконные функции нельзя использовать в условиях после `WHERE`:  
  `WHERE AVG(название_поля) > 100` - не работает.


### [Прочие встроенные функции](#sql)

#### [Функция `DISTINCT`](#sql)

`DISTINCT(имя_поля, имя_поля, ...)` - выводит уникальные значения поля или уникальные комбинации полей.
  -  сочетается с `COUNT`:
        ```SQL
        SELECT COUNT(DISTINCT имя_поля)
        ```
  -  но не сочетается с агрегирующими функциями (подобный запрос выдаст ошибку):
        ```SQL
        SELECT DISTINCT billing_country,
               COUNT(total)
        ```

#### [Функция `CASE`](#sql)

Проверяет истинность набора условий и, в зависимости от результата проверки, возвращает тот или иной результат.
```SQL
CASE
    WHEN условие_1 THEN результат_1
    WHEN условие_2 THEN результат_2
    ...
    WHEN условие_N THEN условие_N
    [ELSE альтернативный_результат]
END
```
Пример:
```SQL
SELECT ProductName, ProductCount, 
CASE
    WHEN ProductCount = 1 
        THEN 'Товар заканчивается'
    WHEN ProductCount = 2 
        THEN 'Мало товара'
    WHEN ProductCount = 3 
        THEN 'Есть в наличии'
    ELSE 'Много товара'
END AS Category
FROM Products;
```

#### [Функция `IF`](#sql)

В зависимости от результата условного выражения возвращает одно из двух значений. Если условие верно, то возвращается первое значение, иначе возвращается второе значение.  
`IF(условие, значение_истина, значение_ложь)`

Пример:
```SQL
SELECT ProductName, Manufacturer,
    IF(ProductCount > 3, 'Много товара', 'Мало товара')
FROM Products;
```

#### [Функция `IFNULL`](#sql)

Проверяет `выражение` и если оно равно NULL, то возвращает `значение`.  
`IFNULL(выражение, значение)`

Пример:
```SQL
SELECT FirstName, LastName,
        IFNULL(Phone, 'не определено') AS Phone,
        IFNULL(Email, 'неизвестно') AS Email
FROM Clients;
```

#### [Функция `COALESCE`](#sql)

Возвращает первое из списка значений, которое не равно NULL.
`COALESCE(выражение_1, выражение_2, ..., выражение_N)`

Пример:
```SQL
SELECT FirstName, LastName,
        COALESCE(Phone, Email, 'не определено') AS Contacts
FROM Clients;
```



## [Подзапросы и временные таблицы](#sql)


### [Подзапросы](#sql)

Подзапрос - это обычный SQL-запрос, который создает промежуточную таблицу из результатов которой SQL-запрос извлекает нужные данные.  
Подзапросы вкладываются внутрь запросов и друг друга. Глубина таких вложений определяется СУБД.  
Подзапросы могут применяться:
- в качестве таблицы для выборки в выражении `FROM`;
- в условии в выражениях `WHERE` и `HAVING`;
- в качестве спецификации столбца в выражении `SELECT`.  

```SQL
SELECT названия_полей
FROM (подзапрос) AS псевдоним; 
```
```SQL
SELECT *
FROM название_таблицы
WHERE название_поля IN (подзапрос);
```

Подзапросу в `FROM` нужно всегда назначать псевдоним, иначе произойдёт ошибка.

Подзапросами в `WHERE` можно получить результат аналогичный объединению с помощью `JOIN`, но подзапрос имеет преимущество в скорости выполнения, так как данные сначала отбирают, а потом объединяют в итоговую таблицу.  
В условиях сравнения в `WHERE` подзапрос должен выдавать одно значение. Если требуется сравнить с набором значений из подзапроса, то в условии используются операторы:
- `ALL` - условие в операции сравнения должно быть верно для всех значений, которые возвращаются подзапросом;
- `SOME` или `ANY` - условие в операции сравнения должно быть истинным для хотя бы одного из значений, возвращаемых подзапросом.
  
Пример:
```SQL
SELECT * FROM Products
WHERE Price < ALL(SELECT Price FROM Products WHERE Manufacturer='Apple')
```

Подзапросы часто используют совместно с операторами `IN` и `NOT IN`, например: `SELECT * FROM Products WHERE Id IN (SELECT ProductId FROM Orders)`.

**Коррелирующие подзапросы** (correlated subquery)  
Подзапросы, результаты которых зависят от строк, которые выбираются в основном запросе.  
Пример:
```SQL
SELECT  CreatedAt, Price, 
        (SELECT ProductName FROM Products 
        WHERE Products.Id = Orders.ProductId) AS Product
FROM Orders;
```
Следует учитывать, что коррелирующие подзапросы выполняются для каждой отдельной строки выборки, то выполнение таких подзапросов может замедлять выполнение всего запроса в целом.


### [Временные таблицы (CTE)](#sql)

Временные таблицы (общие табличные выражения - Common Table Expression (CTE)) используют для того, чтобы упорядочить и систематизировать код с подзапросами. Они помогают структурировать подзапросы и вынести их за пределы основного запроса.  
Создание временных таблиц напоминает назначение переменных: псевдониму назначается таблица, сформированная подзапросом. Затем пишут общий запрос, в котором работают с временной таблицей.

```SQL
WITH
псевдоним_1 AS (подзапрос_1),
псевдоним_2 AS (подзапрос_2),
...
псевдоним_n AS (подзапрос_n)

-- далее идет основной запрос внутри которого работают с псевдонимами, назначенными в WITH
SELECT
FROM псевдоним_1 INNER JOIN псевдоним_2 ... 
...
```


### [Представления (VIEW)](#sql)

Представление — это виртуальная таблица, не содержащая данных, содержимое которой определяется запросом (SELECT). Данные в этой таблице появляются динамически при обращении к представлению.  
Представления бывают: пользовательские – создаваемые пользователями и системные – существующие на SQL сервере и возвращающие системную информацию.

```SQL
USE base1;

-- создание представления
CREATE VIEW shema1.view_name AS  
SELECT column1, column2, column3   
FROM table1;
GO

-- вызов представления
SELECT column1,
       column3
FROM shema1.view_name
ORDER BY column1;
GO

-- изменение представления
ALTER VIEW shema1.view_name AS  
SELECT column1, column2, column3   
FROM table1
WHERE column2 > 1000;
GO

-- изменение данных в таблице через представление
UPDATE shema1.view_name SET column3 = column3 + 10
   WHERE column1 = 2;
GO

-- удаление представления, если оно есть
IF OBJECT_ID('shema1.view_name', 'V') IS NOT NULL
    DROP VIEW view_name;
```



## [Объединение таблиц](#sql)


### [Операторы `JOIN` (горизонтальное объединение)](#sql)

Обычно таблицы объединяют после того, как получили срез и сгруппировали данные, так как объединение больших таблиц занимает много времени. Таблицу лучше предварительно обработать и уже потом объединять данные.  
В PostgreSQL можно объединять таблицы не только по ключам (первичным и внешним), но и по полям с одинаковыми названиями и похожим содержанием.

Правила объединения таблиц:
- после оператора FROM назначают первую таблицу;
- затем следует оператор `JOIN` нужного типа;
- после оператора `JOIN` указывают вторую таблицу и поля, по которым объединяют данные.

```SQL
...
FROM таблица_1 AS псевдоним_1
    INNER JOIN таблица_2 ON таблица_1.имя_поля = таблица_2.имя_поля --первое присоединение
    LEFT OUTER JOIN таблица_3 AS псевдоним_3 ON псевдоним_1.имя_поля = псевдоним_3.имя_поля --второе присоединение
...
```

Типы оператора `JOIN`:
- `INNER JOIN` (или `JOIN`) - включит в итоговую таблицу только те данные, которые являются общими для двух таблиц в столбцах по которым объединяют таблицы.
- `LEFT OUTER JOIN` (или `LEFT JOIN`) - в результат слияния обязательно войдут все записи из левой таблицы. Записи из правой таблицы сохранятся только в том случае, если значения в поле, по которому происходит объединение, совпадают со значениями в левой таблице. Если нужных данных в правой таблице нет, то будет указано значение NULL.
- `RIGHT OUTER JOIN` (или `RIGHT JOIN`) - в результат слияния обязательно войдут все записи из правой таблицыю Записи из левой таблицы сохранятся только в том случае, если значения в поле, по которому происходит объединение, совпадают со значениями в правой таблице. Если нужных данных в левой таблице нет, то будет указано значение NULL. В некоторых СУБД не используется, так как вместо него можно использовать `LEFT OUTER JOIN` поменяв местами объединяемые таблицы.
- `FULL OUTER JOIN` (или `FULL JOIN`) - объединяет все данные из левой и правой таблиц по столбцу, по которому объединяют таблицы. Если не нашлось совпадения, на месте значения будет NULL.  
Нужно применять осторожно, так как крупные таблицы при использовании `FULL OUTER JOIN` могут увеличиться ещё больше, что усложнит работу с данными.
- `CROSS JOIN` - возвращает декартово произведение строк объединяемых таблиц (каждой строке первой таблицы сопоставляются все строки второй таблицы) В объединенной таблице образуется `количество_строк_таблицы_1 * количество_строк_таблицы_2` строк. Этот вид объединения таблиц самый объемный.
- Неявное объединение таблиц - `FROM таблица_1, таблица_2, ..., таблица_N` - аналогично `CROSS JOIN` создает декартово произведение строк всех объединяемых таблиц. Такое объединение нужно ограничивать условиями равенства ключевых полей объединяемых таблиц в `WHERE`.  
  Пример: `SELECT * FROM Orders, Customers WHERE Orders.CustomerId = Customers.Id;`

Хорошей практикой является сформировать несколько подзапросов и объединить их результаты, вместо того чтобы сначала объединять таблицы, а потом убирать лишнее:
```SQL
...
FROM (подзапрос_1) LEFT OUTER JOIN (подзапрос_2) ON ...
...
```


### [Операторы `UNION` (вертикальное объединение)](#sql)

Операторы `UNION` и `UNION ALL` используют, чтобы объединить выдачу нескольких SQL-запросов, "приклеивая" их друг к другу снизу. При этом должны выполняться следующие условия:
- Порядок извлечения полей из таблиц в `SELECT` должен быть одинаковым.
- Количество извлекаемых полей в запросах должно совпадать.
- Типы данных в полях должны соответствовать друг другу (например, объединить поля типа `integer` и `real` можно, а поля типа `integer` и `varchar` нельзя).

Оператор `UNION` образовавшиеся при объединении дубликаты строк в итоговую таблицу не включает, оператор `UNION ALL` - включает.

```SQL
SQL_запрос_1
UNION ALL
SQL_запрос_2
UNION ALL
...;
```

Примеры:
- объединение одинаковых полей из двух разных таблиц с исключением дубликатов, применена сортировка (сортировка ориентируется на названия полей первой таблицы):
```SQL
SELECT FirstName, LastName
FROM Customers
UNION ALL
SELECT FirstName, LastName 
FROM Employees
ORDER BY FirstName;
```
- объединение одних и те же полей из одной таблицы с разными условиями в `WHERE`, расчетные поля рассчитаны по разным формулам:
```SQL
SELECT FirstName, LastName, AccountSum + AccountSum * 0.1 AS TotalSum 
FROM Customers WHERE AccountSum < 3000
UNION
SELECT FirstName, LastName, AccountSum + AccountSum * 0.3 AS TotalSum 
FROM Customers WHERE AccountSum >= 3000;
```



## [Оконные функции](#sql)

Оконные функции выполняют вычисления для набора записей, объединённых по какому-либо признаку. Такой набор называют окном. Оконная функция для каждой записи выводит значение, сохраняя независимость записей. Этим она отличается от агрегирующей функции, которая тоже вычисляется для набора записей, но объединяет записи в одну.

Оконная функция задается выражением `OVER()`.  
Выражение `OVER` может быть пустым. В этом случае оконная функция будет равнозначна агрегирующей функции.

Внутри выражения `OVER()` находятся операторы:
- `PARTITION BY` - отвечает за разделение записей на окна (группы) в зависимости от значений, содержащихся в поле, которое указано в `PARTITION BY`. Записи с одинаковыми значениями поля оказываются в одном окне. Для каждого из окон рассчитывается результат оконной функции.
- `ORDER BY` - отвечает за сортировку внутри оконной функции по указанному в `ORDER BY` полю. С ключевым словом `DESC` сортирует по убыванию, например: `ROW_NUMBER() OVER (ORDER BY имя_поля DESC)`. Возможна сортировка по нескольким полям.

В общем виде оконная функция выглядит следующим образом:
```SQL
SELECT ...
       функция() OVER(PARTITION BY название_поля_1 ORDER BY название_поля_2) AS псевдоним
...
```


### [Функции в составе оконных функций](#sql)

- Ранжирования:
  - `ROW_NUMBER()` - возвращает порядковый номер записи в окне, нумеруя записи в зависимости от параметров `PARTITION BY` и `ORDER BY`, всегда устанавливает каждой записи уникальный ранг;
  - `RANK()` - возвращает порядковый номер записи в окне в зависимости от параметров `PARTITION BY` и `ORDER BY`, одинаковым значениям присваивает одинаковый ранг, при нумерации пропускает номера рангов после нескольких записей одного ранга;
  - `DENSE_RANK()` - возвращает порядковый номер записи в окне в зависимости от параметров `PARTITION BY` и `ORDER BY`, одинаковым значениям присваивает одинаковый ранг, назначает ранги последовательно (без пропусков);
  - `NTILE(количество_групп)` - назначает записям фиксированное количество рангов, разделяя записи на равные группы;
- Смещения:
  - `LAG(имя_поля, смещение, значение_по_умолчанию)` - возвращает предыдущие записи относительно текущей;
  - `LEAD(имя_поля, смещение, значение_по_умолчанию)` - возвращает последующие записи относительно текущей;  
  Математичесткими операциями с участием этих функций можно показать изменения между значениями в разных точках отсчета.
- Агрегирующие: `AVG()`, `MIN()`, `MAX()`, `SUM()`, `COUNT()`. В качестве аргумента агрегирующей функции указывается поле, по значениям которого нужно сделать рассчет.  
Агрегирующие функции, при использовании в составе оконных, считают куммулятивно (с накоплением) по группам (окнам), если используется оператор `PARTITION BY`, и в целом, если оператор `PARTITION BY` не используется.


### [Конструкция `WINDOW`](#sql)

Применяется для замены определения окна (содержания `OVER`), если оно встречается несколько раз, чтобы облегчить восприятие кода.  
Синтаксис у конструкции: `WINDOW название_окна AS определение_окна`.  
Пример:

```SQL
SELECT *,
       ROW_NUMBER() OVER my_window,
       RANK() OVER my_window,
       DENSE_RANK() OVER one_more_window
FROM online_store.orders
WINDOW my_window AS (ORDER BY revenue)
       one_more_window AS (PARTITION BY user_id);
```


### [Ограничения оконных функций](#sql)

- `DISTINCT` нельзя использовать в аргументе оконной функции:
  - `SELECT COUNT(DISTINCT название_поля)` - работает;
  - `SELECT COUNT(DISTINCT название_поля) OVER (ORDER BY название_поля_2)` - не работает.
- Оконные функции нельзя сочетать с группировкой:
  - `GROUP BY название_поля, COUNT(*) OVER (PARTITION BY название_поля)` - не работает.
- Оконные функции нельзя использовать в условиях после `WHERE`:
  - `WHERE COUNT(*) OVER (PARTITION BY название_поля) = 100` - не работает.



## [Индексы](#sql)

Индекс является структурой на диске, которая связана с таблицей или представлением и ускоряет получение строк из таблицы или представления. Индекс содержит ключи, построенные из одного или нескольких столбцов в таблице или представлении. Эти ключи хранятся в виде структуры сбалансированного дерева, которая поддерживает быстрый поиск строк по их ключевым значениям в SQL Server.

Типы индексов в Microsoft SQL Server:
- *Rowstore*:
  - *Кластеризованный (Clustered)* – сортирует и хранит строки данных таблицы или представления в порядке, определяемом ключом кластеризованного индекса. Кластеризованный индекс реализуется в виде сбалансированного дерева, которое поддерживает быстрое получение строк по значениям ключа кластеризованного индекса.
  - *Некластеризованный (Nonclustered)* – содержит значение ключа и указатель на строку данных, содержащую значение этого ключа. У таблицы может быть несколько некластеризованных индексов. Создаваться некластеризованные индексы можно как для таблиц с кластеризованным индексом, так и без него. Используется для повышения производительности часто используемых запросов.
  - *Фильтруемый (Filtered)* – оптимизированный некластеризованный индекс, который использует предикат фильтра для индексирования части строк в таблице. Повышает производительность запросов, при этом снижает затраты на обслуживание и хранение индексов по сравнению с полнотабличными индексами.
  - *Уникальный (Unique)* – обеспечивает отсутствие повторяющихся значений ключа индекса, что, в свою очередь, приводит к тому, что каждая строка в таблице или представлении является в каком-то смысле уникальной. При создании уникального индекса по нескольким столбцам, индекс гарантирует уникальность каждой комбинации значений в ключе. Уникальными могут быть как кластеризованные, так и некластеризованные индексы. При создании ограничений PRIMARY KEY или UNIQUE для ключевых столбцов автоматически создается уникальный индекс.
- *Columnstore* -  хранит и управляет данными с использованием основанного на столбцах хранилища данных и обработки запросов. Значительно повышает производительность и сокращает использование помяти за счет сжатия данных. Особенно хорошо подходит для хранилищ данных, которые выполняют массовую загрузку и запросы только для чтения.
- Прочие индексы (*full-text*, *XML* и др.).

Пример создания некластеризованного индекса с ограничением уникальности и указания порядка сортировки:
```SQL
CREATE UNIQUE INDEX index1 ON schema1.table1 (column1 DESC, column2 ASC, column3 DESC);
```

Пример удаления двух индексов:
```SQL
DROP INDEX index1 ON database_name.schema_name1.table1_or_view1_name,
            index2 ON schema_name2.table2_or_view2_name;
```



## [Разное](#sql)


### [Просмотр таблиц и типов данных в них](#sql)

- Просмотр всех таблиц в базе данных (полная информация, если часть информации не нужна, то надо указать требуемые поля в SELECT):
```sql
SELECT *
FROM information_schema.tables;
```
Можно просмотреть все таблицы в конкретной схеме, добавив в запрос `WHERE table_schema = 'schema_name'`.

- Просмотр типов данных в полях таблицы `table_name`, находящейся в схеме `schema_name`:

```sql
SELECT column_name, data_type
FROM information_schema.columns
WHERE table_schema = 'schema_name'
  AND table_name = 'table_name';
```


### [Команда `EXPLAIN`](#sql)

Возвращает план выполнения запроса для инструкции SQL без выполнения самой инструкции. Используется для предварительного просмотра операций, требующих перемещения данных, а также для просмотра предполагаемых затрат на выполнение запроса.

```SQL
EXPLAIN SQL_statement\G;
```
, где:
- `SQL_statement` - может быть одной из следующих команд: SELECT, INSERT, UPDATE, DELETE, CREATE TABLE AS SELECT, CREATE REMOTE TABLE;
- `\G` - указание для MySQL выводить данные построчно.


### [Рекомендации по оптимизации SQL-запросов](#sql)

- Использовать `DISTINCT` только тогда, когда это действительно необходимо, так как увеличивает время выполнения запроса из-за необходимости выполнения операции удаления дубликатов.
- Если сортировка не является необходимой (особенно если сортировка выполняется по большому количеству данных), то лучше избегать использования `ORDER BY`, либо использовать сортировку в интерфейсе программы:
  - путем экспорта в excel с последующим использованием встроенных фильтров (если дальнейшая работа с данными предстоит excel);
  - путем сортировки в BI-инструменте, если скрипт будет использован там.
- Указывать только необходимые поля в `SELECT` вместо `*`.
- Вместо оператора `IN` для проверки наличия значения в списке использовать оператор `EXISTS`, который останавливается при первом совпадении, в то время как `IN` выполняет полное сканирование списка значений.
- Не использовать оператор `LIKE` там, где можно использовать точное определение значения через равенство или можно использовать справочник для определения по идентификаторам.
- Не использовать оператор `UNION`, если не требуется удаление дубликатов при соединении таблиц. Использовать `UNION ALL`.
- Минимизировать использование множественных вложенных подзапросов, лучше заменять их на временные таблицы (CTE) через `WITH ... AS ...`.
- Рекомендации по объединению таблиц через `JOIN`:
  - не использовать `CROSS JOIN`, так как он возвращает декартово произведение строк из обеих таблиц;
  - не использовать `FULL JOIN` без особой необходимости;
  - не использовать `LEFT JOIN` в тех случаях, где достаточно использования `INNER JOIN`;
  - рекомендации по использованию ключей в `JOIN`:
    - не использовать соединение по неравенству полей (`!=`):  
    `LEFT JOIN ORDERS o ON o.SALE_ID != s.SALE_ID` - нежелательно использовать `!=`;
    - не использовать преобразование данных в ключах соединения таблиц:
    `LEFT JOIN ORDERS o ON TO_NUMBER(o.SALE_ID) = s.SALE_ID` - нежелательно использовать `TO_NUMBER` и ему подобное преобразование;
    - минимизировать использование в качестве ключей атрибутов, связи по которым выполняются по принципу "многие-ко-многим";
    - не использовать соединение по текстовым полям (с типом `varchar`, `char`, `text` и т.п.);
    - не использовать оператор OR в условии соединения таблиц:
    - `LEFT JOIN ORDERS o ON (o.SALE_ID = s.SALE_ID OR o.job_id = j.job_id)` - нежелательно использовать `OR` между ключами.
- Аккуратно использовать подсказки `HINT`.  
  Примеры HINT-подсказок:
  - `SELECT /+ PARALLEL(employees, 4) / * FROM employees` - указывает оптимизатору использовать параллельное выполнение запросов для распределения нагрузки и ускорения выполнения запросов;
  - `SELECT /+ INDEX(employees idx_employees_name) / * FROM employees` - указывает оптимизатору использовать конкретный индекс или объединение;
  - `/+ FULL(table_name) /` - указывает оптимизатору использовать полное сканирование таблицы вместо индексного сканирования;
  - `/+ ORDERED /` - указывает оптимизатору сохранять порядок соединения таблиц, как указано в запросе;
  - `/+ USE_HASH (table_name) /` - указывает оптимизатору использовать хэш-соединение для выполнения запроса;
  - `/+ LEADING (table_name) /` - указывает оптимизатору начать соединение таблиц с указанной таблицы;
  - `/+ NO_MERGE /` - указывает оптимизатору не объединять несколько операций в одну;
  - `/+ NO_EXPAND /` - указывает оптимизатору не использовать расширение представлений для выполнения запроса;
  - `/+ OPT_PARAM (parameter value) /` - позволяет установить значение параметра оптимизации запроса.