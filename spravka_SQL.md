# SQL

**Оглавление**

- [SQL](#sql)
  - [Порядок записи и выполнения операторов SQL-запроса](#порядок-записи-и-выполнения-операторов-sql-запроса)
    - [Порядок записи операторов](#порядок-записи-операторов)
    - [Порядок выполнения операторов](#порядок-выполнения-операторов)
  - [Типы данных и изменение типов данных](#типы-данных-и-изменение-типов-данных)
    - [Операторы и функции для работы с датой и временем](#операторы-и-функции-для-работы-с-датой-и-временем)
  - [Математические операции](#математические-операции)
  - [Агрегирующие функции](#агрегирующие-функции)
    - [Ограничения агрегирующих функций](#ограничения-агрегирующих-функций)
    - [Функция `DISTINCT`](#функция-distinct)
  - [Подзапросы и временные таблицы](#подзапросы-и-временные-таблицы)
    - [Подзапросы](#подзапросы)
    - [Временные таблицы (CTE)](#временные-таблицы-cte)
  - [Объединение таблиц](#объединение-таблиц)
    - [Операторы `JOIN` (горизонтальное объединение)](#операторы-join-горизонтальное-объединение)
    - [Операторы `UNION` (вертикальное объединение)](#операторы-union-вертикальное-объединение)
  - [Оконные функции](#оконные-функции)
    - [Функции в составе оконных функций](#функции-в-составе-оконных-функций)
    - [Конструкция `WINDOW`](#конструкция-window)
    - [Ограничения оконных функций](#ограничения-оконных-функций)
  - [Разное](#разное)
    - [Просмотр таблиц и типов данных в них](#просмотр-таблиц-и-типов-данных-в-них)
    - [Рекомендации по оптимизации SQL-запросов](#рекомендации-по-оптимизации-sql-запросов)

SQL - обладающий вариативностью декларативный язык, с помощью которого описывают конечный результат, а не алгоритм.

База данных - структура в которой данные упорядочены и связаны между собой.

Реляционная база данных - структура в которой данные представлены в виде связанных таблиц.  
Таблицы содержат: строки, поля, ячейки.  
В таблицах реляционной базы отсутствуют дубликаты, все записи уникальны.  
Для каждой записи добавляется уникальный признак - первичный ключ - поле или набор полей таблицы с уникальными значениями, однозначно идентифицирующими строки таблицы.  
Связь между таблицами в базе данных обеспечивается внешними ключами, с их помощью таблицы можно объединять.  
Схема - уровень структуризации реляционной базы данных. Каждая база данных содержит одну или несколько схем, в которые, в свою очередь, входят таблицы. В разных схемах могут быть таблицы с одинаковыми названиями. Если при создании таблицы не добавить конкретную схему, то таблица будет помещена в схему public, которая по умолчанию входит в каждую новую базу данных PostgreSQL. Если таблица находится в схеме public, то название схемы в запросе можно не указывать.  
В общем случае название схемы указывается через точку перед названием таблицы, например: `FROM shema.tablica`.  
Поле таблицы указывается или своим названием, или своим названием через точку после названия таблицы,например: `tablica.pole`.



## [Порядок записи и выполнения операторов SQL-запроса](#sql)


### [Порядок записи операторов](#sql)

```SQL
SELECT ..., ... AS ... --выбор данных для отображения
    DISTINCT ..., ... /*выбор уникальных значений*/
    CASE --выбор данных по условию
        WHEN ... THEN ...
        WHEN ... AND ... THEN ...
        ELSE ...
    END
    SUM/AVG/MIN/MAX/COUNT() --применение агрегирующих функций
    функция() OVER(PARTITION BY ... ORDER BY ...) AS ... --применение оконных функций
FROM таблица_1 AS псевдоним_1
    INNER JOIN таблица_2 ON таблица_1.имя_поля = таблица_2.имя_поля --первое присоединение
    LEFT OUTER JOIN таблица_3 AS псевдоним_3 ON псевдоним_1.имя_поля = псевдоним_3.имя_поля --второе присоединение
    RIGHT OUTER JOIN --третье присоединение
    FULL OUTER JOIN --четвертое присоединение
WHERE ... --получение среза данных
    AND NOT ...
    AND ... IN (..., ..., ...)
    AND ... NOT IN (...)
    AND ... LIKE '%...%'
    AND ... NOT LIKE '%...%'
    OR ... BETWEEN ... AND ...
    OR ... IS NULL
    OR ... IS NOT NULL
WINDOW ...
GROUP BY ..., ... --группировка данных
HAVING ... --получение среза после GROUP BY
ORDER BY ..., ... DESC, ... ASC --сортировка перед выводом данных
LIMIT ... OFFSET ...; -- ограничение количества выводимых данных
```

*Примечения:*  
- Псевдонимы (собственные названия для чего-либо) назначаются через `AS`.
- Псевдонимы таблиц, назначенные в `FROM`, можно использовать в любом месте запроса.
- Псевдонимы полей отображения, назначенные в `SELECT`, можно использовать только в `ORDER BY` (в некоторых SQL ещё и в `GROUP BY`).
- `SELECT *` - выбор всех полей таблицы.
- `SELECT` работает как функция вывода на экран (print), если он один и после него указать строку или число, например:
    ```SQL
    SELECT 'на экране отображается число', 5;
    ```


### [Порядок выполнения операторов](#sql)

1. Первым выполняется оператор `FROM`, так как сначала нужно определить, откуда брать данные. На этом же этапе с помощью оператора `JOIN` объединяются таблицы и назначаются псевдонимы для таблиц.  
Важно учесть, что присоединение предшествует фильтрации и группировке. Это означает, что большие таблицы будут объединяться очень долго. В этом случае рекомендуется использовать временные таблицы.
2. Затем выполняется оператор `WHERE`, который оставляет только те данные, которые соответствуют условиям (срезы).
3. После срезов выполняется группировка оператором `GROUP BY` и подсчёт данных агрегирующими функциями.  
Обратите внимание, что `WHERE` предшествует `GROUP BY`, что не позволяет сделать срез по группам (в момент получения среза группировка ещё не произошла).
4. Далее наступает очередь `HAVING` — отбираются уже сгруппированные данные.
5. Только после этого происходит выбор данных с помощью оператора `SELECT` и полям в итоговой таблице присваиваются псевдонимы. По этой причине псевдонимы нельзя использовать после `WHERE` и `HAVING` — они ещё не назначены (в некоторых СУБД псевдонимы нельзя использовать и после `GROUP BY`).
6. После `SELECT` срабатывает ключевое слово `DISTINCT`, которое отбирает уникальные значения.
7. Оператор `ORDER BY` действует предпоследним, выполняя сортировку.
8. Последним выполняется оператор `LIMIT`.



## [Типы данных и изменение типов данных](#sql)

В разных СУБД типы данных могут отличаться, но типы данных часто можно объединить в похожие группы. В PostgreSQL выделяют следующие группы [типов данных](https://postgrespro.ru/docs/postgresql/15/datatype):
- числовые типы:
  - `integer` (псевдоним `int` или `int4`) - целые числа;
  - `real` (псевдоним `float4`) - вещественные числа (4 байта);
  - `double precision` (псевдоним `float8`) - вещественные числа (8 байт);
- символьные типы:
  - `character` (псевдоним `char(n)`, где n - количество символов) - символьная строка фиксированной длины;
  - `character varying` (псевдоним `varchar(n)`, где n - количество символов, который можно не уквзывать) - символьная строка переменной длины;
  - `text` - символьная строка переменной длины (не для всех SQL);
- логические типы:
  - `boolean` (псевдоним `bool`) - логическое значение:
    - `TRUE` (варианты обозначения: `true`, `t`, `yes`, `y`, `on`, `1`);
    - `FALSE` (варианты обозначения: `false`, `f`, `no`, `n`, `off`, `0`);
- типы для работы с датой и временем:
  - `timestamp` - дата и время без учета часового пояса (например, 2004-10-19 10:23:54);
  - `timestamptz` - дата и время с учетом часового пояса (например, 2004-10-19 10:23:54+02);
  - `date` - дата (например, `2004-10-19`, `October 19, 2004`, `2004-Oct-19` или `20041019`);
  - `time` - время без учета часового пояса;
  - `timetz` - время с учетом часового пояса;
  - `interval` - интервал времени;
- разные специализированные типы для конкретных задач.


**Изменение типа данных при выгрузке (в самой базе данные не меняются):**
```SQL
CAST(имя_поля AS тип_данных)
```
Альтернативный вариант изменения типа данных при выгрузке:
```SQL
имя_поля::тип_данных
```


### [Операторы и функции для работы с датой и временем](#sql)

```SQL
SELECT CURRENT_DATE --вернёт текущую дату.
SELECT CURRENT_TIME --выведет текущее время.
SELECT CURRENT_TIMESTAMP --вернёт текущие дату и время.
```

**Усечение даты-времени до определенного значения**  
До определенного значения не урезается, а округляется, например, до первого дня месяца или первого января года. Возвращает данные типов `timestamp` или `interval`.
```SQL
DATE_TRUNC('отрезок времени', имя_поля)
```
, где отрезок времени это:
- `microseconds` — микросекунды;
- `milliseconds` — миллисекунды;
- `second` — секунда;
- `minute` — минута;
- `hour` — час;
- `day` — день;
- `week` — неделя;
- `month` — месяц;
- `quarter` — квартал;
- `year` — год;
- `decade` — десятилетие;
- `century` — век.

**Получение конкретной части даты-времени**  
Вырезает из даты-времени указанную часть. Возвращает данные типа `double precision` (вещественное число).
```SQL
EXTRACT(отрезок времени FROM имя_поля)
```
, где отрезок времени это:
- `CENTURY` — век;
- `DAY` — день;
- `DOY` — день года, выраженный числом от 1 до 365 (366 для високосного года);
- `DOW` — день недели, выраженный числом от 0 до 6 (понедельник — 1, воскресенье — 0);
- `ISODOW` — день недели, выраженный числом от 1 до 7 (понедельник — 1, воскресенье — 7);
- `HOUR` — час;
- `MILLISECOND` — миллисекунда;
- `MINUTE` — минута;
- `MONTH` — месяц;
- `SECOND` — секунда;
- `QUARTER` — квартал;
- `WEEK` — неделя в году;
- `YEAR` — год.

*Примечание*  
Функции `DATE_TRUNC` и `EXTRACT` при работе автоматически переводят типы `date` и `time` в `timestamp with time zone`. В результате время может сдвинуться.  
Чтобы этого избежать, надо при применении функции принудительно изменить тип данных на `timestamp`. Например: `EXTRACT(YEAR FROM CAST(имя_поля AS timestamp))`.


## [Математические операции](#sql)

- `ABS()` - возвращает модуль числа;
- `CEILING()` - возвращает число, округлённое до целого в большую сторону;
- `FLOOR()` - возвращает число, округлённое до целого в меньшую сторону;
- `ROUND(число, количество_знаков_после_запятой)` - округляет значение до ближайшего целого числа (если не указано количество знаков после запятой) или до указанного количества знаков после запятой;
- `TRUNC(число, количество_знаков_после_запятой)` - усекает значение до ближайшего целого числа (если не указано количество знаков после запятой) или до указанного количества знаков после запятой, но число, в отличии от `ROUND`, не округляется;
- `POWER(число, степень)` - возвращает число, возведённое в степень;
- `SQRT()` - возврящает квадратный корень из числа.


## [Агрегирующие функции](#sql)

Применяютя после оператора `SELECT`. Можно сочетать с математическими функциями.

- `SUM(имя_поля)` - возвращает сумму значений;
- `AVG(имя_поля)` - находит среднее арифметическое для значений;
- `MIN(имя_поля)` - возвращает минимальное значение;
- `МАХ(имя_поля)` - возвращает максимальное значение;
- `COUNT(*)` - выводит количество записей в таблице;
- `COUNT(имя_поля)` - выводит количество записей в поле.


### [Ограничения агрегирующих функций](#sql)

- Оконные функции нельзя использовать в условиях после `WHERE`:
  - `WHERE AVG(название_поля) > 100` - не работает.


### [Функция `DISTINCT`](#sql)

`DISTINCT(имя_поля, имя_поля, ...)` - выводит уникальные значения поля или уникальные комбинации полей.
  -  сочетается с `COUNT`:
        ```SQL
        SELECT COUNT(DISTINCT имя_поля)
        ```
  -  но не сочетается с агрегирующими функциями (подобный запрос выдаст ошибку):
        ```SQL
        SELECT DISTINCT billing_country,
               COUNT(total)
        ```



## [Подзапросы и временные таблицы](#sql)


### [Подзапросы](#sql)

Подзапрос - это обычный SQL-запрос, который создает промежуточную таблицу из результатов которой SQL-запрос извлекает нужные данные.  
Подзапросы вкладываются внутрь запросов и друг друга. Глубина таких вложений определяется СУБД.  
Подзапросы могут применяться в `FROM` и в `WHERE`.  
Подзапросу в `FROM` нужно всегда назначать псевдоним, иначе произойдёт ошибка.  
Подзапросами в `WHERE` можно получить результат аналогичный объединению с помощью `JOIN`, но подзапрос имеет преимущество в скорости выполнения, так как данные сначала отбирают, а потом объединяют в итоговую таблицу.

```SQL
SELECT названия_полей
FROM (подзапрос) AS псевдоним; 
```
```SQL
SELECT *
FROM название_таблицы
WHERE название_поля IN (подзапрос);
```


### [Временные таблицы (CTE)](#sql)

Временные таблицы (общие табличные выражения - Common Table Expression (CTE)) используют для того, чтобы упорядочить и систематизировать код с подзапросами. Они помогают структурировать подзапросы и вынести их за пределы основного запроса.  
Создание временных таблиц напоминает назначение переменных: псевдониму назначается таблица, сформированная подзапросом. Затем пишут общий запрос, в котором работают с временной таблицей.

```SQL
WITH
псевдоним_1 AS (подзапрос_1),
псевдоним_2 AS (подзапрос_2),
...
псевдоним_n AS (подзапрос_n)

-- далее идет основной запрос внутри которого работают с псевдонимами, назначенными в WITH
SELECT
FROM псевдоним_1 INNER JOIN псевдоним_2 ... 
...
```



## [Объединение таблиц](#sql)


### [Операторы `JOIN` (горизонтальное объединение)](#sql)

Обычно таблицы объединяют после того, как получили срез и сгруппировали данные, так как объединение больших таблиц занимает много времени. Таблицу лучше предварительно обработать и уже потом объединять данные.  
В PostgreSQL можно объединять таблицы не только по ключам (первичным и внешним), но и по полям с одинаковыми названиями и похожим содержанием.

Правила объединения таблиц:
- после оператора FROM назначают первую таблицу;
- затем следует оператор `JOIN` нужного типа;
- после оператора `JOIN` указывают вторую таблицу и поля, по которым объединяют данные.

```SQL
...
FROM таблица_1 AS псевдоним_1
    INNER JOIN таблица_2 ON таблица_1.имя_поля = таблица_2.имя_поля --первое присоединение
    LEFT OUTER JOIN таблица_3 AS псевдоним_3 ON псевдоним_1.имя_поля = псевдоним_3.имя_поля --второе присоединение
...
```

Типы оператора `JOIN`:
- `INNER JOIN` (или `JOIN`) - включит в итоговую таблицу только те данные, которые являются общими для двух таблиц в столбцах по которым объединяют таблицы.
- `LEFT OUTER JOIN` (или `LEFT JOIN`) - в результат слияния обязательно войдут все записи из левой таблицы. Записи из правой таблицы сохранятся только в том случае, если значения в поле, по которому происходит объединение, совпадают со значениями в левой таблице. Если нужных данных в правой таблице нет, то будет указано значение NULL.
- `RIGHT OUTER JOIN` (или `RIGHT JOIN`) - в результат слияния обязательно войдут все записи из правой таблицыю Записи из левой таблицы сохранятся только в том случае, если значения в поле, по которому происходит объединение, совпадают со значениями в правой таблице. Если нужных данных в левой таблице нет, то будет указано значение NULL. В некоторых СУБД не используется, так как вместо него можно использовать `LEFT OUTER JOIN` поменяв местами объединяемые таблицы.
- `FULL OUTER JOIN` (или `FULL JOIN`) - объединяет все данные из левой и правой таблиц по столбцу, по которому объединяют таблицы. Если не нашлось совпадения, на месте значения будет NULL.  
Нужно применять осторожно, так как крупные таблицы при использовании `FULL OUTER JOIN` могут увеличиться ещё больше, что усложнит работу с данными.

Хорошей практикой является сформировать несколько подзапросов и объединить их результаты, вместо того чтобы сначала объединять таблицы, а потом убирать лишнее:
```SQL
...
FROM (подзапрос_1) LEFT OUTER JOIN (подзапрос_2) ON ...
...
```


### [Операторы `UNION` (вертикальное объединение)](#sql)

Операторы `UNION` и `UNION ALL` используют, чтобы объединить выдачу нескольких SQL-запросов, "приклеивая" их друг к другу снизу. При этом должны выполняться следующие условия:
- Порядок извлечения полей из таблиц в `SELECT` должен быть одинаковым.
- Количество извлекаемых полей в запросах должно совпадать.
- Типы данных в полях должны соответствовать друг другу (например, объединить поля типа `integer` и `real` можно, а поля типа `integer` и `varchar` нельзя).

Оператор `UNION` образовавшиеся при объединении дубликаты строк в итоговую таблицу не включает, оператор `UNION ALL` - включает.

```SQL
SQL_запрос_1
UNION ALL
SQL_запрос_2
UNION ALL
...;
```



## [Оконные функции](#sql)

Оконные функции выполняют вычисления для набора записей, объединённых по какому-либо признаку. Такой набор называют окном. Оконная функция для каждой записи выводит значение, сохраняя независимость записей. Этим она отличается от агрегирующей функции, которая тоже вычисляется для набора записей, но объединяет записи в одну.

Оконная функция задается выражением `OVER()`.  
Выражение `OVER` может быть пустым. В этом случае оконная функция будет равнозначна агрегирующей функции.

Внутри выражения `OVER()` находятся операторы:
- `PARTITION BY` - отвечает за разделение записей на окна (группы) в зависимости от значений, содержащихся в поле, которое указано в `PARTITION BY`. Записи с одинаковыми значениями поля оказываются в одном окне. Для каждого из окон рассчитывается результат оконной функции.
- `ORDER BY` - отвечает за сортировку внутри оконной функции по указанному в `ORDER BY` полю. С ключевым словом `DESC` сортирует по убыванию, например: `ROW_NUMBER() OVER (ORDER BY имя_поля DESC)`. Возможна сортировка по нескольким полям.

В общем виде оконная функция выглядит следующим образом:
```SQL
SELECT ...
       функция() OVER(PARTITION BY название_поля_1 ORDER BY название_поля_2) AS псевдоним
...
```


### [Функции в составе оконных функций](#sql)

- Ранжирования:
  - `ROW_NUMBER()` - возвращает порядковый номер записи в окне, нумеруя записи в зависимости от параметров `PARTITION BY` и `ORDER BY`, всегда устанавливает каждой записи уникальный ранг;
  - `RANK()` - возвращает порядковый номер записи в окне в зависимости от параметров `PARTITION BY` и `ORDER BY`, одинаковым значениям присваивает одинаковый ранг, при нумерации пропускает номера рангов после нескольких записей одного ранга;
  - `DENSE_RANK()` - возвращает порядковый номер записи в окне в зависимости от параметров `PARTITION BY` и `ORDER BY`, одинаковым значениям присваивает одинаковый ранг, назначает ранги последовательно (без пропусков);
  - `NTILE(количество_групп)` - назначает записям фиксированное количество рангов, разделяя записи на равные группы;
- Смещения:
  - `LAG(имя_поля, смещение, значение_по_умолчанию)` - возвращает предыдущие записи относительно текущей;
  - `LEAD(имя_поля, смещение, значение_по_умолчанию)` - возвращает последующие записи относительно текущей;  
  Математичесткими операциями с участием этих функций можно показать изменения между значениями в разных точках отсчета.
- Агрегирующие: `AVG()`, `MIN()`, `MAX()`, `SUM()`, `COUNT()`. В качестве аргумента агрегирующей функции указывается поле, по значениям которого нужно сделать рассчет.  
Агрегирующие функции, при использовании в составе оконных, считают куммулятивно (с накоплением) по группам (окнам), если используется оператор `PARTITION BY`, и в целом, если оператор `PARTITION BY` не используется.


### [Конструкция `WINDOW`](#sql)

Применяется для замены определения окна (содержания `OVER`), если оно встречается несколько раз, чтобы облегчить восприятие кода.  
Синтаксис у конструкции: `WINDOW название_окна AS определение_окна`.  
Пример:

```SQL
SELECT *,
       ROW_NUMBER() OVER my_window,
       RANK() OVER my_window,
       DENSE_RANK() OVER one_more_window
FROM online_store.orders
WINDOW my_window AS (ORDER BY revenue)
       one_more_window AS (PARTITION BY user_id);
```


### [Ограничения оконных функций](#sql)

- `DISTINCT` нельзя использовать в аргументе оконной функции:
  - `SELECT COUNT(DISTINCT название_поля)` - работает;
  - `SELECT COUNT(DISTINCT название_поля) OVER (ORDER BY название_поля_2)` - не работает.
- Оконные функции нельзя сочетать с группировкой:
  - `GROUP BY название_поля, COUNT(*) OVER (PARTITION BY название_поля)` - не работает.
- Оконные функции нельзя использовать в условиях после `WHERE`:
  - `WHERE COUNT(*) OVER (PARTITION BY название_поля) = 100` - не работает.



## [Разное](#sql)


### [Просмотр таблиц и типов данных в них](#sql)

- Просмотр всех таблиц в базе данных (полная информация, если часть информации не нужна, то надо указать требуемые поля в SELECT):
```sql
SELECT *
FROM information_schema.tables;
```
Можно просмотреть все таблицы в конкретной схеме, добавив в запрос `WHERE table_schema = 'schema_name'`.

- Просмотр типов данных в полях таблицы `table_name`, находящейся в схеме `schema_name`:

```sql
SELECT column_name, data_type
FROM information_schema.columns
WHERE table_schema = 'schema_name'
  AND table_name = 'table_name';
```


### [Рекомендации по оптимизации SQL-запросов](#sql)

- Использовать `DISTINCT` только тогда, когда это действительно необходимо, так как увеличивает время выполнения запроса из-за необходимости выполнения операции удаления дубликатов.
- Если сортировка не является необходимой (особенно если сортировка выполняется по большому количеству данных), то лучше избегать использования `ORDER BY`, либо использовать сортировку в интерфейсе программы:
  - путем экспорта в excel с последующим использованием встроенных фильтров (если дальнейшая работа с данными предстоит excel);
  - путем сортировки в BI-инструменте, если скрипт будет использован там.
- Указывать только необходимые поля в `SELECT` вместо `*`.
- Вместо оператора `IN` для проверки наличия значения в списке использовать оператор `EXISTS`, который останавливается при первом совпадении, в то время как `IN` выполняет полное сканирование списка значений.
- Не использовать оператор `LIKE` там, где можно использовать точное определение значения через равенство или можно использовать справочник для определения по идентификаторам.
- Не использовать оператор `UNION`, если не требуется удаление дубликатов при соединении таблиц. Использовать `UNION ALL`.
- Минимизировать использование множественных вложенных подзапросов, лучше заменять их на временные таблицы (CTE) через `WITH ... AS ...`.
- Рекомендации по объединению таблиц через `JOIN`:
  - не использовать `CROSS JOIN`, так как он возвращает декартово произведение строк из обеих таблиц;
  - не использовать `FULL JOIN` без особой необходимости;
  - не использовать `LEFT JOIN` в тех случаях, где достаточно использования `INNER JOIN`;
  - рекомендации по использованию ключей в `JOIN`:
    - не использовать соединение по неравенству полей (`!=`):  
    `LEFT JOIN ORDERS o ON o.SALE_ID != s.SALE_ID` - нежелательно использовать `!=`;
    - не использовать преобразование данных в ключах соединения таблиц:
    `LEFT JOIN ORDERS o ON TO_NUMBER(o.SALE_ID) = s.SALE_ID` - нежелательно использовать `TO_NUMBER` и ему подобное преобразование;
    - минимизировать использование в качестве ключей атрибутов, связи по которым выполняются по принципу "многие-ко-многим";
    - не использовать соединение по текстовым полям (с типом `varchar`, `char`, `text` и т.п.);
    - не использовать оператор OR в условии соединения таблиц:
    - `LEFT JOIN ORDERS o ON (o.SALE_ID = s.SALE_ID OR o.job_id = j.job_id)` - нежелательно использовать `OR` между ключами.
- Аккуратно использовать подсказки `HINT`.  
  Примеры HINT-подсказок:
  - `SELECT /+ PARALLEL(employees, 4) / * FROM employees` - указывает оптимизатору использовать параллельное выполнение запросов для распределения нагрузки и ускорения выполнения запросов;
  - `SELECT /+ INDEX(employees idx_employees_name) / * FROM employees` - указывает оптимизатору использовать конкретный индекс или объединение;
  - `/+ FULL(table_name) /` - указывает оптимизатору использовать полное сканирование таблицы вместо индексного сканирования;
  - `/+ ORDERED /` - указывает оптимизатору сохранять порядок соединения таблиц, как указано в запросе;
  - `/+ USE_HASH (table_name) /` - указывает оптимизатору использовать хэш-соединение для выполнения запроса;
  - `/+ LEADING (table_name) /` - указывает оптимизатору начать соединение таблиц с указанной таблицы;
  - `/+ NO_MERGE /` - указывает оптимизатору не объединять несколько операций в одну;
  - `/+ NO_EXPAND /` - указывает оптимизатору не использовать расширение представлений для выполнения запроса;
  - `/+ OPT_PARAM (parameter value) /` - позволяет установить значение параметра оптимизации запроса.